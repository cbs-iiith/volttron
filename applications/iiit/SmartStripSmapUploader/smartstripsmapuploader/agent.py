# -*- coding: utf-8 -*- {{{
# vim: set fenc=utf-8 ft=python sw=4 ts=4 sts=4 et:


import datetime
import logging
import sys
import uuid

from volttron.platform.vip.agent import Agent, Core, PubSub, compat, RPC
from volttron.platform.agent import utils
from volttron.platform.messaging import headers as headers_mod

from volttron.platform.messaging import topics, headers as headers_mod

import time

import requests
import json

import cPickle

from smap_tools import smap_post

utils.setup_logging()
_log = logging.getLogger(__name__)
__version__ = '0.1'

# Change this to whatever the root of the messages is on your system
# For example, all of the messages being generated by our volttron-level code
# start with LPDM.  E.G. /LPDM/energy_price or /LPDM/power_use
# If you want to listen to all topics just replace the below with empty string ""  
SS_MAIN_TOPIC   = "smartstrip" 
SS_PRICEPOINT   = "prices/PricePoint" 

# This is the information needed to post to smap.  The source_name might be able
# to be derived somehow and the API key and server root could go in a config
# But this seems easier to show for an example.
SMAP_ROOT = "http://chomp.lbl.gov/"
API_KEY = "u606HlEFHTeVLfpBQZkNF232wChljnLHCKBY"
SOURCE_NAME = "LPDM CBERD Flexlab Data"
TIME_ZONE = "US/Pacific"

def DatetimeFromValue(ts):
    ''' Utility for dealing with time
    '''
    if isinstance(ts, (int, long)):
        return datetime.utcfromtimestamp(ts)
    elif isinstance(ts, float):
        return datetime.utcfromtimestamp(ts)
    elif not isinstance(ts, datetime):
        raise ValueError('Unknown timestamp value')
    return ts
    
def smartstripsmapuploader(config_path, **kwargs):
    
    config = utils.load_config(config_path)
    agent_id = config['agentid']
    
    PLUG_ID_1 = 0
    PLUG_ID_2 = 1
    PLUG_ID_3 = 2
    PLUG_ID_4 = 3
    
    ss_main_topic           = config.get('ss_main_topic', SS_MAIN_TOPIC)
    ss_price_point_topic    = config.get('ss_price_point_topic', SS_PRICEPOINT)
    
    Agent.__name__ = 'SmartStripSmapUploader_Agent'
    return SmartStripSmapUploader(**kwargs)
    
class SmartStripSmapUploader(Agent):
    '''
    retrive the data from volttron and pushes it to the BLE UI Server
    '''
    
    def __init__(self, **kwargs):
        _log.debug('__init__()')
        super(SmartStripSmapUploader, self).__init__(**kwargs)
        
    @Core.receiver('onsetup')
    def setup(self, sender, **kwargs):
        _log.debug('setup()')
        _log.info(config['message'])
        self._agent_id = config['agentid']
        
        self.smap_root      = config.get('smap_root', SMAP_ROOT)
        self.api_key        = config.get('api_key', API_KEY)
        self.source_data    = config.get('source_data', SOURCE_NAME)
        self.time_zone      = config.get('time_zone', TIME_ZONE)
        return
        
    @Core.receiver('onstart')            
    def startup(self, sender, **kwargs):
        _log.debug('startup()')
        return
        
    @Core.receiver('onstop')
    def onstop(self, sender, **kwargs):
        _log.debug('onstop()')
        return
        
    @PubSub.subscribe('pubsub', ss_main_topic)
    def on_match_ssData(self, peer, sender, bus, topic, headers, message):
        _log.debug('on_match_ssData()')
        self.ssSmapPostData(self, peer, sender, bus, topic, headers, message)
        return
        
    @PubSub.subscribe('pubsub', ss_price_point_topic)
    def on_match_ssCurrentPP(self, peer, sender, bus, topic, headers, message):
        _log.debug('on_match_ssCurrentPP()')
        _log.debug("topic: " + topic)
        self.ssSmapPostData(peer, sender, bus, topic, headers, message)
        return
        
    def ssSmapPostData(self, peer, sender, bus, topic, headers, message):
        _log.debug('smapPostSSData()')
        # Just check for it or any other messages you don't want to log here
        # and return without doing anything.            
        keywords_to_skip = ["subscriptions", "init", "finished_processing"]
        for keyword in keywords_to_skip:
            if keyword in topic:
                return
                
        _log.debug("topic: " + topic)
        topic = "/" + topic
        
        print "header: " + headers
        print "message: " + message
        
        # this is where you have to take the message and convert it to a smap stream.
        # This currently just uses the VOLTTRON topic as the stream path
        # Extracting the contents of the message depends on what the message looks like
        # In our case I am pickling/unpickling objects that are being generated by a lower
        # level module
        message_time = None
        message_value = None
        
        try:
            message = cPickle.loads(message)
            message_time = max(message_time, message.time)
            if message_time is None:
                message_time = time()
            message_value = message.value
        except Exception as e:
            # there are a few messages that are not objects, assuming their contents
            # are a dict with a value param and an optional timestamp param
            # if there is no timestamp param just use current system time
            message_time = message.get("timestamp", time())
            message_value = message.get("value", None)
            
        # in our case times are being expressed as seconds since the epoch.  However smap
        # expects ms since the epoch so I am multipling by 1000 here.  If you are passing around
        # datetimes you can give those directly to the smap posting code.  It can deal with them
        if type(message_time) is float:
            message_time *= 1000
            
        # I am not sure at the moment how to derive units from a topic in a general sense and we are not
        # passing any unit information in messages.  So absent hard-coding some mapping I'm just leaving
        # the units blank for now.  They can always be filled in later
        units = ""
        reading_type = "double"
        
        #All the message objects we are sending have a time and a value member
        readings = [[message_time, message_value]]
        
        #smap_post(self.smap_root, self.api_key, topic, units, reading_type, readings, self.source_data, self.time_zone)
        return
        
    return



def main(argv=sys.argv):
    '''Main method called by the eggsecutable.'''
    try:
        utils.vip_main(smartstripsmapuploader)
    except Exception as e:
        print e
        _log.exception('unhandled exception')

if __name__ == '__main__':
    try:
        sys.exit(main(sys.argv))
    except KeyboardInterrupt:
        pass
        