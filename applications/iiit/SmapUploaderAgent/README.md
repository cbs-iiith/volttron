VOLTTRON agent that listens to messages and posts their contents to smap.  

Since the main point of the agent is to translate whatever messages are being posted to VOLTTRON into something that can be posted to smap it will necessarily depend on how you are structuring your topics and message.


The VOLTTRON agent code as well as a smap_tools.py file.  

That file depends on 
 * requests and 
 * pytz 

 so you will need to install both of them via pip unless you have them already

The agent code is in the agent.py file as usual.

At the top after the imports there are some things in all caps.  All of those can potentially go in a config file or something.  The first is just the most-root topic you want to listen to.  In our case all of the messages generated by our agents start with LPDM/ so our base topic is LPDM.  If you don't have a base topic use empty string "" instead.

Next is some stuff to specify the smap parameters.  The only think of real importance is the SOURCE_NAME.  In smap the source name is what is displayed on the most root level of the tree.  In the following picture I put a red box around the sourcename and a blue box around the stream path (will discuss stream path next):

Inline image 1
One of the assumptions this code makes is that the VOLTTRON topic should be the smap stream path.  In the picture above you can see that the path is /LPDM/energy_price_from_producer/utility_meter_1.  That is because one of the topics in VOLTTRON is LPDM/energy_price_from_producer/utility_meter_1.  The code just turns the VOLTTRON topic into the stream path directly.

Finally there are the contents of the VOLTTRON message that should actually get posted to smap.  The code currently works for two different cases.  

The first is that the message contents is actually some pickled python object.  This is because a lot of the messages we are passing in LPDM around are actually event objects generated by a lower-level non-VOLTTRON module.  Each of these events has a time and value member where the time can potentially be None.  The code posts those values using the current system time if time is None.

E.G. if the message looks like an instance of this class was then pickled:

class Some_Message(object):
    def __init__(self, time, value):
        self.time = time
        self.value = value

Second is if the message contents are a dictionary with a required "value" field and an optional "timestamp".  The code posts those values again using the current system time if timestamp is missing.

E.G. if the message is a dict that looks like this

{ "timestamp" : 1491963764, "value" : 123}

A quick note on time:  We are using UTC time in seconds since the epoch for time in our system.  Since smap wants times in milliseconds since the epoch I am multiplying the time by 1000 before passing it to the smap uploader.  If you are using python datetimes it should still work just fine.  However if you are internally using milliseconds since 1970 we will need to do an easy adjustment.

